module Compiler::Parser {
    use Core::Types::{Result, ParserError, Position}
    use Core::Collections::{Vector, HashMap}
    use Compiler::Lexer::{Token, TokenType}
    use Compiler::AST::*
    use Core::System::{Effect, Visibility}

    type Parser {
        tokens: Vector<Token>,
        current: usize,
        had_error: bool,
        panic_mode: bool,
        errors: Vector<ParserError>,
        scope_level: u64,
        scope_id_counter: u64
    }

    impl Parser {
        // Initialize a new parser
        func new(tokens: Vector<Token>) -> Self {
            Parser {
                tokens: tokens,
                current: 0,
                had_error: false,
                panic_mode: false,
                errors: Vector::new(),
                scope_level: 0,
                scope_id_counter: 0
            }
        }

        // Main parsing function
        func parse(&mut self) -> Result<Program> {
            let mut program = Program::new();

            // Parse imports first
            while self.match_token(TokenType::Use) {
                match self.use_declaration() {
                    Ok(decl) => program.imports.push(decl),
                    Err(e) => {
                        self.errors.push(e);
                        self.synchronize();
                    }
                }
            }

            // Parse declarations
            while !self.is_at_end() {
                match self.declaration() {
                    Ok(decl) => {
                        if self.match_token(TokenType::Export) {
                            program.exports.push(ExportDecl {
                                item: Box::new(decl),
                                alias: if self.match_token(TokenType::As) {
                                    Some(self.consume(TokenType::Identifier, "Expected export alias")?.lexeme)
                                } else {
                                    None
                                }
                            });
                        } else {
                            program.declarations.push(decl);
                        }
                    },
                    Err(e) => {
                        self.errors.push(e);
                        self.synchronize();
                    }
                }
            }

            if self.had_error {
                Err(ParserError::MultipleErrors(self.errors.clone()))
            } else {
                Ok(program)
            }
        }

        // Declaration parsing
        func declaration(&mut self) -> Result<Declaration> {
            if self.match_token(TokenType::Module) {
                self.module_declaration()
            } else if self.match_token(TokenType::Class) {
                self.class_declaration()
            } else if self.match_token(TokenType::Trait) {
                self.trait_declaration()
            } else if self.match_token(TokenType::Interface) {
                self.interface_declaration()
            } else if self.match_token(TokenType::Function) {
                self.function_declaration()
            } else if self.match_token(TokenType::Let) || self.match_token(TokenType::Var) {
                self.variable_declaration()
            } else if self.match_token(TokenType::Type) {
                self.type_declaration()
            } else if self.match_token(TokenType::Effect) {
                self.effect_declaration()
            } else if self.match_token(TokenType::Import) {
                self.import_declaration()
            } else if self.match_token(TokenType::Export) {
                self.export_declaration()
            } else if self.match_token(TokenType::LinearType) {
                self.linear_type_declaration()
            } else if self.match_token(TokenType::Region) {
                self.region_declaration()
            } else if self.match_token(TokenType::Actor) {
                self.actor_declaration()
            } else {
                self.statement()
            }
        }

        // Class parsing
        func class_declaration(&mut self) -> Result<Declaration> {
            let name = self.consume(TokenType::Identifier, "Expected class name")?;
            let mut class = ClassDecl::new(name.lexeme);
            
            // Parse generics
            if self.match_token(TokenType::Less) {
                class.generics = self.generic_parameters()?;
            }
            
            // Parse inheritance
            if self.match_token(TokenType::Extends) {
                class.superclass = Some(self.type_expression()?);
            }
            
            if self.match_token(TokenType::Implements) {
                class.interfaces = self.separated_list(TokenType::Comma, |p| p.type_expression())?;
            }
            
            // Parse effects
            if self.match_token(TokenType::With) {
                class.effects = self.effect_list()?;
            }
            
            // Parse class body
            self.consume(TokenType::LeftBrace, "Expected '{' before class body")?;
            
            while !self.check(TokenType::RightBrace) && !self.is_at_end() {
                match self.class_member()? {
                    ClassMember::Field(f) => class.fields.push(f),
                    ClassMember::Method(m) => class.methods.push(m),
                    ClassMember::Constructor(c) => class.constructors.push(c),
                }
            }
            
            self.consume(TokenType::RightBrace, "Expected '}' after class body")?;
            
            Ok(Declaration::Class(class))
        }

        // Trait parsing
        func trait_declaration(&mut self) -> Result<Declaration> {
            let name = self.consume(TokenType::Identifier, "Expected trait name")?;
            let mut trait_decl = TraitDecl::new(name.lexeme);
            
            // Parse generics
            if self.match_token(TokenType::Less) {
                trait_decl.generics = self.generic_parameters()?;
            }
            
            // Parse super traits
            if self.match_token(TokenType::Extends) {
                trait_decl.supertraits = self.separated_list(TokenType::Comma, |p| p.type_expression())?;
            }
            
            // Parse associated types
            if self.match_token(TokenType::Where) {
                trait_decl.associated_types = self.associated_type_list()?;
            }
            
            // Parse trait body
            self.consume(TokenType::LeftBrace, "Expected '{' before trait body")?;
            
            while !self.check(TokenType::RightBrace) && !self.is_at_end() {
                trait_decl.body.push(self.trait_member()?);
            }
            
            self.consume(TokenType::RightBrace, "Expected '}' after trait body")?;
            
            Ok(Declaration::Trait(trait_decl))
        }

        // Effect parsing
        func effect_declaration(&mut self) -> Result<Declaration> {
            let name = self.consume(TokenType::Identifier, "Expected effect name")?;
            let mut effect = EffectDecl::new(name.lexeme);
            
            // Parse effect parameters
            if self.match_token(TokenType::Less) {
                effect.params = self.type_parameter_list()?;
            }
            
            // Parse effect body
            self.consume(TokenType::LeftBrace, "Expected '{' before effect body")?;
            
            while !self.check(TokenType::RightBrace) && !self.is_at_end() {
                effect.operations.push(self.function_declaration()?);
            }
            
            self.consume(TokenType::RightBrace, "Expected '}' after effect body")?;
            
            Ok(Declaration::Effect(effect))
        }

        // Linear type parsing
        func linear_type_declaration(&mut self) -> Result<Declaration> {
            let name = self.consume(TokenType::Identifier, "Expected linear type name")?;
            let mut linear_type = LinearTypeDecl::new(name.lexeme);
            
            // Parse generics
            if self.match_token(TokenType::Less) {
                linear_type.generics = self.generic_parameters()?;
            }
            
            // Parse linear type body
            self.consume(TokenType::LeftBrace, "Expected '{' before linear type body")?;
            
            while !self.check(TokenType::RightBrace) && !self.is_at_end() {
                linear_type.operations.push(self.linear_operation()?);
            }
            
            self.consume(TokenType::RightBrace, "Expected '}' after linear type body")?;
            
            Ok(Declaration::LinearType(linear_type))
        }

        // Region parsing
        func region_declaration(&mut self) -> Result<Declaration> {
            let name = self.consume(TokenType::Identifier, "Expected region name")?;
            let mut region = RegionDecl::new(name.lexeme);
            
            // Parse region lifetime
            if self.match_token(TokenType::Less) {
                region.lifetime = Some(self.parse_lifetime()?);
            }
            
            // Parse region constraints
            if self.match_token(TokenType::Where) {
                region.constraints = self.parse_constraints()?;
            }
            
            // Parse region body
            self.consume(TokenType::LeftBrace, "Expected '{' before region body")?;
            
            region.body = self.parse_block()?;
            
            self.consume(TokenType::RightBrace, "Expected '}' after region body")?;
            
            Ok(Declaration::Region(region))
        }

        // Actor parsing
        func actor_declaration(&mut self) -> Result<Declaration> {
            let name = self.consume(TokenType::Identifier, "Expected actor name")?;
            let mut actor = ActorDecl::new(name.lexeme);
            
            // Parse actor state
            self.consume(TokenType::LeftBrace, "Expected '{' before actor state")?;
            
            while !self.check(TokenType::RightBrace) && !self.is_at_end() {
                match self.current_token()?.type {
                    TokenType::Let | TokenType::Var => actor.state.push(self.parse_variable()?),
                    TokenType::Message => actor.messages.push(self.parse_message()?),
                    TokenType::Behavior => actor.behaviors.push(self.parse_behavior()?),
                    _ => return Err(self.error("Expected state, message, or behavior declaration")),
                }
            }
            
            self.consume(TokenType::RightBrace, "Expected '}' after actor state")?;
            
            Ok(Declaration::Actor(actor))
        }

        // Pattern matching
        func pattern(&mut self) -> Result<Pattern> {
            if self.match_token(TokenType::Underscore) {
                Ok(Pattern::Wildcard)
            } else if self.match_token(TokenType::LeftParen) {
                self.tuple_pattern()
            } else if self.match_token(TokenType::Identifier) {
                let name = self.previous.lexeme.clone();
                
                if self.match_token(TokenType::LeftParen) {
                    // Constructor pattern
                    let patterns = self.separated_list(TokenType::Comma, |p| p.pattern())?;
                    self.consume(TokenType::RightParen, "Expected ')' after constructor pattern")?;
                    Ok(Pattern::Constructor(name, patterns))
                } else {
                    // Variable binding pattern
                    if self.match_token(TokenType::At) {
                        let sub_pattern = self.pattern()?;
                        Ok(Pattern::Binding(name, Some(Box::new(sub_pattern))))
                    } else {
                        Ok(Pattern::Binding(name, None))
                    }
                }
            } else if self.match_token(TokenType::Bar) {
                // Or pattern
                let mut patterns = vec![self.pattern()?];
                while self.match_token(TokenType::Bar) {
                    patterns.push(self.pattern()?);
                }
                Ok(Pattern::Or(patterns))
            } else {
                // Literal pattern
                let expr = self.primary()?;
                Ok(Pattern::Literal(expr))
            }
        }

        // Type system
        func type_expression(&mut self) -> Result<TypeExpr> {
            let start_pos = self.current.pos;
            let kind = if self.match_token(TokenType::Identifier) {
                let name = self.previous.lexeme.clone();
                
                if self.match_token(TokenType::Less) {
                    // Generic type
                    let params = self.separated_list(TokenType::Comma, |p| p.type_expression())?;
                    self.consume(TokenType::Greater, "Expected '>' after type parameters")?;
                    TypeKind::Named(Identifier::new(&name), params)
                } else {
                    TypeKind::Named(Identifier::new(&name), vec![])
                }
            } else if self.match_token(TokenType::LeftParen) {
                // Tuple or function type
                let mut params = vec![self.type_expression()?];
                
                while self.match_token(TokenType::Comma) {
                    if self.check(TokenType::RightParen) {
                        break;
                    }
                    params.push(self.type_expression()?);
                }
                
                self.consume(TokenType::RightParen, "Expected ')' after type parameters")?;
                
                if self.match_token(TokenType::Arrow) {
                    // Function type
                    let return_type = Box::new(self.type_expression()?);
                    let effects = if self.match_token(TokenType::With) {
                        self.effect_list()?
                    } else {
                        vec![]
                    };
                    TypeKind::Function(params, return_type, effects)
                } else {
                    // Tuple type
                    TypeKind::Tuple(params)
                }
            } else if self.match_token(TokenType::LeftBracket) {
                // Array type
                let element_type = Box::new(self.type_expression()?);
                let size = if self.match_token(TokenType::Semicolon) {
                    Some(Box::new(self.expression()?))
                } else {
                    None
                };
                self.consume(TokenType::RightBracket, "Expected ']' after array type")?;
                TypeKind::Array(element_type, size)
            } else if self.match_token(TokenType::Ampersand) {
                // Reference type
                let is_mutable = self.match_token(TokenType::Mut);
                let referenced_type = Box::new(self.type_expression()?);
                TypeKind::Reference(referenced_type, is_mutable)
            } else {
                return Err(ParserError::ExpectedTypeExpression(self.current));
            };
            
            Ok(TypeExpr {
                kind,
                pos: start_pos,
            })
        }

        // Helper methods
        func advance(&mut self) -> Token {
            self.previous = self.current.clone();
            
            loop {
                self.current = self.tokens[self.current].clone();
                if self.current.type_ != TokenType::Error {
                    break;
                }
                
                self.error_at_current(&self.current.lexeme);
            }
            
            self.previous.clone()
        }
        
        func consume(&mut self, type_: TokenType, message: &str) -> Result<Token> {
            if self.check(type_) {
                Ok(self.advance())
            } else {
                Err(ParserError::ExpectedToken(type_, message, self.current.pos))
            }
        }
        
        func match_token(&mut self, type_: TokenType) -> bool {
            if self.check(type_) {
                self.advance();
                true
            } else {
                false
            }
        }
        
        func check(&self, type_: TokenType) -> bool {
            if self.is_at_end() {
                false
            } else {
                self.current.type_ == type_
            }
        }
        
        func is_at_end(&self) -> bool {
            self.current.type_ == TokenType::Eof
        }
        
        func synchronize(&mut self) {
            self.panic_mode = false;
            
            while !self.is_at_end() {
                if self.previous.type_ == TokenType::Semicolon {
                    return;
                }
                
                match self.current.type_ {
                    TokenType::Class |
                    TokenType::Function |
                    TokenType::Let |
                    TokenType::For |
                    TokenType::If |
                    TokenType::While |
                    TokenType::Return |
                    TokenType::Import |
                    TokenType::Export => return,
                    _ => {}
                }
                
                self.advance();
            }
        }
        
        func error_at_current(&mut self, message: &str) {
            self.error_at(self.current.clone(), message);
        }
        
        func error_at(&mut self, token: Token, message: &str) {
            if self.panic_mode {
                return;
            }
            self.panic_mode = true;
            self.had_error = true;
            
            eprintln!("[line {}] Error", token.pos.line);
            
            match token.type_ {
                TokenType::Eof => eprint!(" at end"),
                TokenType::Error => {},
                _ => eprint!(" at '{}'", token.lexeme),
            }
            
            eprintln!(": {}", message);
        }

        // Parse effect declarations
        func parse_effect(&mut self) -> Result<EffectDecl> {
            let name = self.expect_identifier()?;
            let generics = if self.match_token(TokenType::Lt) {
                self.parse_generic_params()?
            } else {
                Vec::new()
            };

            self.expect(TokenType::LBrace)?;
            let mut operations = Vec::new();
            let mut handlers = Vec::new();

            while !self.check(TokenType::RBrace) {
                if self.match_token(TokenType::Handler) {
                    handlers.push(self.parse_handler()?);
                } else {
                    operations.push(self.parse_effect_operation()?);
                }
            }

            self.expect(TokenType::RBrace)?;
            Ok(EffectDecl { name, generics, operations, handlers })
        }

        // Parse effect operations
        func parse_effect_operation(&mut self) -> Result<EffectOpDecl> {
            let name = self.expect_identifier()?;
            self.expect(TokenType::LParen)?;
            let params = self.parse_params()?;
            self.expect(TokenType::RParen)?;
            
            let return_type = if self.match_token(TokenType::Arrow) {
                self.parse_type()?
            } else {
                TypeExpr::unit()
            };

            let constraints = if self.match_token(TokenType::Where) {
                self.parse_constraints()?
            } else {
                Vec::new()
            };

            Ok(EffectOpDecl { name, params, return_type, constraints })
        }

        // Parse linear type declarations
        func parse_linear_type(&mut self) -> Result<LinearTypeDecl> {
            let name = self.expect_identifier()?;
            let generics = if self.match_token(TokenType::Lt) {
                self.parse_generic_params()?
            } else {
                Vec::new()
            };

            self.expect(TokenType::LBrace)?;
            let mut operations = Vec::new();
            let mut destructor = None;

            while !self.check(TokenType::RBrace) {
                if self.match_token(TokenType::Destructor) {
                    if destructor.is_some() {
                        return Err(self.error("Multiple destructors in linear type"));
                    }
                    destructor = Some(self.parse_function()?);
                } else {
                    operations.push(self.parse_linear_operation()?);
                }
            }

            self.expect(TokenType::RBrace)?;
            Ok(LinearTypeDecl { name, generics, operations, destructor })
        }

        // Parse region declarations
        func parse_region(&mut self) -> Result<RegionDecl> {
            let name = self.expect_identifier()?;
            let lifetime = if self.match_token(TokenType::Lt) {
                Some(self.parse_lifetime()?)
            } else {
                None
            };

            let constraints = if self.match_token(TokenType::Where) {
                self.parse_constraints()?
            } else {
                Vec::new()
            };

            let body = self.parse_block()?;
            Ok(RegionDecl { name, lifetime, constraints, body })
        }

        // Parse actor declarations
        func parse_actor(&mut self) -> Result<ActorDecl> {
            let name = self.expect_identifier()?;
            self.expect(TokenType::LBrace)?;
            
            let mut state = Vec::new();
            let mut messages = Vec::new();
            let mut behaviors = Vec::new();

            while !self.check(TokenType::RBrace) {
                match self.current_token()?.type {
                    TokenType::Let | TokenType::Var => state.push(self.parse_variable()?),
                    TokenType::Message => messages.push(self.parse_message()?),
                    TokenType::Behavior => behaviors.push(self.parse_behavior()?),
                    _ => return Err(self.error("Expected state, message, or behavior declaration")),
                }
            }

            self.expect(TokenType::RBrace)?;
            Ok(ActorDecl { name, state, messages, behaviors })
        }

        // Parse string interpolation
        func parse_string_interpolation(&mut self) -> Result<StringInterpolationExpr> {
            let mut parts = Vec::new();
            
            self.expect(TokenType::StringStart)?;
            
            while !self.check(TokenType::StringEnd) {
                if self.match_token(TokenType::String) {
                    parts.push(StringPart::Literal(self.previous_token()?.lexeme));
                } else if self.match_token(TokenType::Dollar) {
                    self.expect(TokenType::LBrace)?;
                    let expr = self.parse_expression()?;
                    self.expect(TokenType::RBrace)?;
                    parts.push(StringPart::Expression(Box::new(expr)));
                }
            }
            
            self.expect(TokenType::StringEnd)?;
            Ok(StringInterpolationExpr { parts })
        }

        // Parse async/await expressions
        func parse_async_expression(&mut self) -> Result<AsyncExpr> {
            let return_type = if self.match_token(TokenType::Arrow) {
                self.parse_type()?
            } else {
                TypeExpr::unit()
            };
            
            let body = self.parse_block()?;
            Ok(AsyncExpr { body, return_type })
        }

        fn parse_await_expression(&mut self) -> Result<AwaitExpr> {
            let target = Box::new(self.parse_expression()?);
            Ok(AwaitExpr { target })
        }

        // Parse spawn expressions
        func parse_spawn(&mut self) -> Result<SpawnExpr> {
            let kind = if self.match_token(TokenType::Thread) {
                SpawnKind::Thread
            } else if self.match_token(TokenType::Task) {
                SpawnKind::Task
            } else if self.match_token(TokenType::Actor) {
                let name = self.expect_identifier()?;
                SpawnKind::Actor(name)
            } else {
                return Err(self.error("Expected thread, task, or actor"));
            };

            let body = Box::new(self.parse_expression()?);
            Ok(SpawnExpr { kind, body })
        }

        // Parse dependent types
        func parse_dependent_type(&mut self) -> Result<DependentTypeDecl> {
            let name = self.expect_identifier()?;
            self.expect(TokenType::LParen)?;
            let params = self.parse_params()?;
            self.expect(TokenType::RParen)?;
            
            self.expect(TokenType::Where)?;
            let refinement = Box::new(self.parse_expression()?);
            
            Ok(DependentTypeDecl { name, params, refinement })
        }

        // Parse refinement types
        func parse_refinement_type(&mut self) -> Result<RefinementTypeDecl> {
            let base_type = self.parse_type()?;
            self.expect(TokenType::LBrace)?;
            let predicate = Box::new(self.parse_expression()?);
            self.expect(TokenType::RBrace)?;
            
            Ok(RefinementTypeDecl { base_type, predicate })
        }
    }
}
