// Error handling for the Seoggi compiler

#[derive(Debug, Clone, PartialEq)]
pub struct Position {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
}

impl Position {
    pub fn new(line: usize, column: usize) -> Self {
        Self {
            line,
            column,
            offset: 0,
        }
    }
}

#[derive(Debug)]
pub struct Error {
    pub kind: ErrorKind,
    pub pos: Position,
}

impl Error {
    pub fn new(kind: ErrorKind, pos: Position) -> Self {
        Self { kind, pos }
    }
}

#[derive(Debug)]
pub enum ErrorKind {
    // Lexical errors
    UnexpectedCharacter(char),
    UnterminatedStringLiteral,
    UnterminatedCharacterLiteral,
    EmptyCharacterLiteral,
    CharacterLiteralContainsMoreThanOneCharacter,
    InvalidEscapeSequence(char),
    InvalidHexadecimalNumber,
    InvalidInteger,
    InvalidFloatingPointNumber,
    UnterminatedMultiLineComment,
    InvalidIdentifier,
    
    // Parser errors
    UnexpectedToken(String),
    ExpectedToken(String),
    InvalidExpression,
    InvalidStatement,
    InvalidDeclaration,
    InvalidType,
    
    // Type checker errors
    TypeMismatch {
        expected: String,
        found: String,
    },
    UndefinedVariable(String),
    UndefinedType(String),
    UndefinedFunction(String),
    InvalidTypeArguments {
        expected: usize,
        found: usize,
    },
    
    // Effect system errors
    UnhandledEffect(String),
    InvalidEffectHandler,
    EffectInPureContext,
    
    // Memory management errors
    UseAfterMove(String),
    InvalidBorrow,
    InvalidLifetime,
    
    // General errors
    IOError(String),
    InternalError(String),
    
    // Lexical analysis errors
    LexicalError,
}

impl std::fmt::Display for ErrorKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ErrorKind::UnexpectedCharacter(c) => write!(f, "Unexpected character: {}", c),
            ErrorKind::UnterminatedStringLiteral => write!(f, "Unterminated string literal"),
            ErrorKind::UnterminatedCharacterLiteral => write!(f, "Unterminated character literal"),
            ErrorKind::EmptyCharacterLiteral => write!(f, "Empty character literal"),
            ErrorKind::CharacterLiteralContainsMoreThanOneCharacter => {
                write!(f, "Character literal contains more than one character")
            }
            ErrorKind::InvalidEscapeSequence(c) => write!(f, "Invalid escape sequence: \\{}", c),
            ErrorKind::InvalidHexadecimalNumber => write!(f, "Invalid hexadecimal number"),
            ErrorKind::InvalidInteger => write!(f, "Invalid integer"),
            ErrorKind::InvalidFloatingPointNumber => write!(f, "Invalid floating-point number"),
            ErrorKind::UnterminatedMultiLineComment => write!(f, "Unterminated multi-line comment"),
            ErrorKind::InvalidIdentifier => write!(f, "Invalid identifier"),
            ErrorKind::UnexpectedToken(t) => write!(f, "Unexpected token: {}", t),
            ErrorKind::ExpectedToken(t) => write!(f, "Expected token: {}", t),
            ErrorKind::InvalidExpression => write!(f, "Invalid expression"),
            ErrorKind::InvalidStatement => write!(f, "Invalid statement"),
            ErrorKind::InvalidDeclaration => write!(f, "Invalid declaration"),
            ErrorKind::InvalidType => write!(f, "Invalid type"),
            ErrorKind::TypeMismatch { expected, found } => {
                write!(f, "Type mismatch: expected {}, found {}", expected, found)
            }
            ErrorKind::UndefinedVariable(name) => write!(f, "Undefined variable: {}", name),
            ErrorKind::UndefinedType(name) => write!(f, "Undefined type: {}", name),
            ErrorKind::UndefinedFunction(name) => write!(f, "Undefined function: {}", name),
            ErrorKind::InvalidTypeArguments { expected, found } => {
                write!(
                    f,
                    "Invalid number of type arguments: expected {}, found {}",
                    expected, found
                )
            }
            ErrorKind::UnhandledEffect(effect) => write!(f, "Unhandled effect: {}", effect),
            ErrorKind::InvalidEffectHandler => write!(f, "Invalid effect handler"),
            ErrorKind::EffectInPureContext => write!(f, "Effect used in pure context"),
            ErrorKind::UseAfterMove(var) => write!(f, "Use of moved value: {}", var),
            ErrorKind::InvalidBorrow => write!(f, "Invalid borrow"),
            ErrorKind::InvalidLifetime => write!(f, "Invalid lifetime"),
            ErrorKind::IOError(msg) => write!(f, "IO error: {}", msg),
            ErrorKind::InternalError(msg) => write!(f, "Internal error: {}", msg),
            ErrorKind::LexicalError => write!(f, "Lexical analysis failed"),
        }
    }
}

impl std::error::Error for Error {}
